# Dot_D1 机器人上位机开发指南

## 概述

本指南详细介绍如何开发Dot_D1四足机器人的上位机控制程序，包括BLE蓝牙连接、指令协议、状态监控等完整功能。开发者可以基于本指南实现各种平台的遥控应用（PC、手机、平板等）。

## 1. 系统架构

### 1.1 通信架构
```
上位机应用 <---> BLE GATT Client <---> BLE GATT Server <---> Dot_D1机器人
```

### 1.2 核心组件
- **BLE GATT服务器**: 运行在机器人上，提供控制接口
- **上位机客户端**: 连接到GATT服务器，发送控制指令
- **指令处理系统**: 解析并执行运动控制指令
- **状态反馈系统**: 实时返回机器人状态信息

## 2. BLE连接规范

### 2.1 设备发现
- **设备名称**: `Dot_D1_Robot`
- **服务UUID**: `12345678-1234-1234-1234-123456789abc`
- **扫描方式**: BLE被动扫描或主动发现
- **信号强度**: 建议RSSI > -80dBm以确保稳定连接

### 2.2 GATT服务特征值

#### 控制指令特征值（写入）
- **UUID**: `87654321-4321-4321-4321-cba987654321`
- **权限**: `WRITE`
- **数据格式**: UTF-8编码的JSON字符串
- **最大长度**: 512字节

#### 状态反馈特征值（读取/通知）
- **UUID**: `11111111-2222-3333-4444-555555555555`
- **权限**: `READ | NOTIFY`
- **数据格式**: UTF-8编码的JSON字符串
- **更新频率**: 10Hz（可配置）

## 3. 指令协议详解

### 3.1 JSON指令格式
所有指令都采用JSON格式，基本结构：
```json
{
    "cmd": "指令类型",
    "参数1": "值1",
    "参数2": "值2"
}
```

### 3.2 运动控制指令

#### 3.2.1 精确运动控制
```json
{
    "cmd": "move",
    "x": 0.2,    // 前进后退速度 (-0.2 ~ 0.2)
    "y": 0.1,    // 左右移动速度 (-0.2 ~ 0.2)  
    "z": -0.3    // 旋转速度 (-0.4 ~ 0.4)
}
```

**参数说明**:
- `x`: 正值前进，负值后退
- `y`: 正值左移，负值右移
- `z`: 负值左转，正值右转
- 速度单位: m/s（线性）或 rad/s（角度）

#### 3.2.2 停止运动
```json
{
    "cmd": "stop"
}
```

### 3.3 按键模拟指令

#### 3.3.1 按键指令格式
```json
{
    "cmd": "button",
    "button": 4
}
```

#### 3.3.2 按键映射表
| 按键编号 | 功能 | 等效运动指令 |
|---------|------|-------------|
| 1 | 前进 | `{"cmd":"move","x":0.2,"y":0,"z":0}` |
| 2 | 后退 | `{"cmd":"move","x":-0.2,"y":0,"z":0}` |
| 3 | 左移 | `{"cmd":"move","x":0,"y":0.2,"z":0}` |
| 4 | 右移/启动 | `{"cmd":"move","x":0,"y":-0.2,"z":0}` |
| 5 | 重心微调 | 调整重心参数 |
| 7 | 左转 | `{"cmd":"move","x":0,"y":0,"z":-0.4}` |
| 9 | 右转 | `{"cmd":"move","x":0,"y":0,"z":0.4}` |
| 其他 | 停止 | `{"cmd":"stop"}` |

### 3.4 重心调节指令
```json
{
    "cmd": "center_adjust",
    "adjust": 1    // 1=向前, -1=向后, 0=复位
}
```

### 3.5 心跳保持指令
```json
{
    "cmd": "ping"
}
```

**重要**: 建议每500ms发送一次心跳，超过2秒无指令机器人将自动停止运动。

## 4. 状态反馈协议

### 4.1 状态信息格式
```json
{
    "type": "status",
    "timestamp": 1691234567.89,
    "commands": [0.1, -0.05, 0.2],
    "center_x": 0.001,
    "motor_angle_exceed": 0,
    "imu_angle_exceed": 0,
    "connection_type": "ble"
}
```

### 4.2 状态字段说明
- `timestamp`: Unix时间戳，精确到毫秒
- `commands`: 当前运动指令 [x, y, z]
- `center_x`: 当前重心X轴偏移
- `motor_angle_exceed`: 电机角度超限计数
- `imu_angle_exceed`: IMU角度超限计数
- `connection_type`: 连接类型（固定为"ble"）

## 5. 开发实现指南

### 5.1 Python实现示例

#### 5.1.1 安装依赖
```bash
pip install bleak asyncio
```

#### 5.1.2 基础连接代码
```python
import asyncio
import json
from bleak import BleakClient, BleakScanner

# 设备信息
DEVICE_NAME = "Dot_D1_Robot"
SERVICE_UUID = "12345678-1234-1234-1234-123456789abc"
COMMAND_CHAR_UUID = "87654321-4321-4321-4321-cba987654321"
STATUS_CHAR_UUID = "11111111-2222-3333-4444-555555555555"

class Dot_D1_Controller:
    def __init__(self):
        self.client = None
        self.device = None
    
    async def discover_device(self):
        """扫描并发现Dot_D1机器人"""
        print("正在扫描Dot_D1机器人...")
        devices = await BleakScanner.discover(timeout=10.0)
        
        for device in devices:
            if device.name == DEVICE_NAME:
                self.device = device
                print(f"发现设备: {device.name} ({device.address})")
                return True
        
        print("未发现Dot_D1机器人")
        return False
    
    async def connect(self):
        """连接到机器人"""
        if not self.device:
            if not await self.discover_device():
                return False
        
        try:
            self.client = BleakClient(self.device.address)
            await self.client.connect()
            print(f"已连接到 {self.device.name}")
            
            # 启用状态通知
            await self.client.start_notify(STATUS_CHAR_UUID, self.status_callback)
            return True
            
        except Exception as e:
            print(f"连接失败: {e}")
            return False
    
    async def disconnect(self):
        """断开连接"""
        if self.client and self.client.is_connected:
            await self.client.disconnect()
            print("已断开连接")
    
    def status_callback(self, sender, data):
        """状态回调函数"""
        try:
            status_str = data.decode('utf-8')
            status_data = json.loads(status_str)
            print(f"状态更新: {status_data}")
        except Exception as e:
            print(f"状态解析错误: {e}")
    
    async def send_command(self, command):
        """发送控制指令"""
        if not self.client or not self.client.is_connected:
            print("设备未连接")
            return False
        
        try:
            command_str = json.dumps(command)
            command_bytes = command_str.encode('utf-8')
            await self.client.write_gatt_char(COMMAND_CHAR_UUID, command_bytes)
            print(f"发送指令: {command}")
            return True
            
        except Exception as e:
            print(f"发送指令失败: {e}")
            return False
    
    # 便捷运动控制方法
    async def move_forward(self, speed=0.2):
        """前进"""
        return await self.send_command({"cmd": "move", "x": speed, "y": 0, "z": 0})
    
    async def move_backward(self, speed=0.2):
        """后退"""
        return await self.send_command({"cmd": "move", "x": -speed, "y": 0, "z": 0})
    
    async def move_left(self, speed=0.2):
        """左移"""
        return await self.send_command({"cmd": "move", "x": 0, "y": speed, "z": 0})
    
    async def move_right(self, speed=0.2):
        """右移"""
        return await self.send_command({"cmd": "move", "x": 0, "y": -speed, "z": 0})
    
    async def turn_left(self, speed=0.4):
        """左转"""
        return await self.send_command({"cmd": "move", "x": 0, "y": 0, "z": -speed})
    
    async def turn_right(self, speed=0.4):
        """右转"""
        return await self.send_command({"cmd": "move", "x": 0, "y": 0, "z": speed})
    
    async def stop(self):
        """停止"""
        return await self.send_command({"cmd": "stop"})
    
    async def ping(self):
        """发送心跳"""
        return await self.send_command({"cmd": "ping"})

# 使用示例
async def main():
    controller = Dot_D1_Controller()
    
    # 连接设备
    if await controller.connect():
        try:
            # 发送一些测试指令
            await controller.move_forward(0.1)
            await asyncio.sleep(2)
            
            await controller.turn_left(0.2)
            await asyncio.sleep(1)
            
            await controller.stop()
            
            # 保持连接并定期发送心跳
            for i in range(10):
                await controller.ping()
                await asyncio.sleep(0.5)
                
        finally:
            await controller.disconnect()

# 运行示例
if __name__ == "__main__":
    asyncio.run(main())
```

### 5.2 Android开发要点

#### 5.2.1 权限配置
```xml
<!-- AndroidManifest.xml -->
<uses-permission android:name="android.permission.BLUETOOTH" />
<uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
<uses-permission android:name="android.permission.BLUETOOTH_SCAN" />
<uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
```

#### 5.2.2 核心代码结构
```java
// 主要使用Android的BluetoothAdapter和BluetoothGatt
public class Dot_D1_Controller {
    private BluetoothAdapter bluetoothAdapter;
    private BluetoothGatt bluetoothGatt;
    private BluetoothGattCharacteristic commandCharacteristic;
    private BluetoothGattCharacteristic statusCharacteristic;
    
    // 扫描回调
    private ScanCallback scanCallback;
    
    // GATT回调
    private BluetoothGattCallback gattCallback;
    
    // 发送JSON指令方法
    public boolean sendCommand(JSONObject command);
    
    // 运动控制便捷方法
    public boolean moveForward(float speed);
    public boolean moveBackward(float speed);
    public boolean stop();
}
```

### 5.3 iOS开发要点

#### 5.3.1 框架依赖
```swift
import CoreBluetooth
```

#### 5.3.2 核心类结构
```swift
class Dot_D1_Controller: NSObject, CBCentralManagerDelegate, CBPeripheralDelegate {
    var centralManager: CBCentralManager!
    var dot_d1_peripheral: CBPeripheral?
    var commandCharacteristic: CBCharacteristic?
    var statusCharacteristic: CBCharacteristic?
    
    // 发送指令方法
    func sendCommand(_ command: [String: Any]) -> Bool
    
    // 运动控制方法
    func moveForward(speed: Float)
    func moveBackward(speed: Float)
    func stop()
}
```

## 6. 高级功能开发

### 6.1 实时控制系统

#### 6.1.1 游戏手柄支持
```python
import pygame

class GamepadController:
    def __init__(self, dot_d1_controller):
        pygame.init()
        pygame.joystick.init()
        self.controller = dot_d1_controller
        self.joystick = pygame.joystick.Joystick(0)
        self.joystick.init()
    
    async def process_input(self):
        """处理手柄输入"""
        pygame.event.pump()
        
        # 获取摇杆值
        x_axis = self.joystick.get_axis(0)  # 左右
        y_axis = self.joystick.get_axis(1)  # 前后
        z_axis = self.joystick.get_axis(2)  # 旋转
        
        # 转换为机器人指令
        command = {
            "cmd": "move",
            "x": -y_axis * 0.2,  # 前后反向
            "y": x_axis * 0.2,   # 左右
            "z": z_axis * 0.4    # 旋转
        }
        
        await self.controller.send_command(command)
```

### 6.2 状态监控界面

#### 6.2.1 实时状态显示
```python
import tkinter as tk
from tkinter import ttk

class StatusMonitor:
    def __init__(self, root, controller):
        self.root = root
        self.controller = controller
        self.setup_ui()
    
    def setup_ui(self):
        """设置监控界面"""
        # 连接状态
        self.connection_label = ttk.Label(self.root, text="未连接")
        self.connection_label.pack()
        
        # 运动状态
        self.motion_label = ttk.Label(self.root, text="运动: [0, 0, 0]")
        self.motion_label.pack()
        
        # 重心状态
        self.center_label = ttk.Label(self.root, text="重心: 0.000")
        self.center_label.pack()
        
        # 控制按钮
        button_frame = ttk.Frame(self.root)
        button_frame.pack()
        
        ttk.Button(button_frame, text="前进", command=self.move_forward).grid(row=0, column=1)
        ttk.Button(button_frame, text="左移", command=self.move_left).grid(row=1, column=0)
        ttk.Button(button_frame, text="停止", command=self.stop).grid(row=1, column=1)
        ttk.Button(button_frame, text="右移", command=self.move_right).grid(row=1, column=2)
        ttk.Button(button_frame, text="后退", command=self.move_backward).grid(row=2, column=1)
    
    def update_status(self, status_data):
        """更新状态显示"""
        self.motion_label.config(text=f"运动: {status_data['commands']}")
        self.center_label.config(text=f"重心: {status_data['center_x']:.3f}")
    
    def move_forward(self):
        asyncio.create_task(self.controller.move_forward())
    
    def move_backward(self):
        asyncio.create_task(self.controller.move_backward())
    
    def move_left(self):
        asyncio.create_task(self.controller.move_left())
    
    def move_right(self):
        asyncio.create_task(self.controller.move_right())
    
    def stop(self):
        asyncio.create_task(self.controller.stop())
```

### 6.3 自动控制程序

#### 6.3.1 巡逻模式
```python
async def patrol_mode(controller):
    """自动巡逻模式"""
    print("开始自动巡逻...")
    
    patrol_sequence = [
        {"cmd": "move", "x": 0.15, "y": 0, "z": 0},      # 前进3秒
        {"cmd": "move", "x": 0, "y": 0, "z": 0.3},       # 右转1秒
        {"cmd": "move", "x": 0.15, "y": 0, "z": 0},      # 前进3秒
        {"cmd": "move", "x": 0, "y": 0, "z": 0.3},       # 右转1秒
    ]
    
    durations = [3, 1, 3, 1]  # 每个动作持续时间
    
    while True:
        for i, (command, duration) in enumerate(zip(patrol_sequence, durations)):
            await controller.send_command(command)
            await asyncio.sleep(duration)
            
            # 发送心跳保持连接
            await controller.ping()
        
        # 完成一轮巡逻后停止1秒
        await controller.stop()
        await asyncio.sleep(1)
```

## 7. 故障排除

### 7.1 连接问题

#### 7.1.1 设备发现失败
**可能原因**:
- 机器人BLE服务未启动
- 蓝牙适配器被禁用
- 距离过远或信号干扰

**解决方案**:
```bash
# 在机器人上检查BLE状态
hciconfig hci0
systemctl status bluetooth

# 确保启动脚本包含BLE初始化
./Dot_D1_launch.sh
```

#### 7.1.2 连接中断
**可能原因**:
- 心跳超时（2秒）
- 蓝牙信号不稳定
- 系统资源不足

**解决方案**:
- 实现自动重连机制
- 增加心跳频率（建议500ms）
- 添加连接状态监控

### 7.2 指令异常

#### 7.2.1 指令无响应
**检查步骤**:
1. 验证JSON格式正确性
2. 确认特征值UUID正确
3. 检查字符编码（必须UTF-8）
4. 验证参数范围

#### 7.2.2 运动异常
**常见问题**:
- 速度参数超出范围
- 指令发送频率过高
- 机器人状态异常

**调试方法**:
```python
# 添加指令验证
def validate_command(command):
    if command.get("cmd") == "move":
        x = command.get("x", 0)
        y = command.get("y", 0)
        z = command.get("z", 0)
        
        if not (-0.2 <= x <= 0.2):
            raise ValueError(f"x速度超出范围: {x}")
        if not (-0.2 <= y <= 0.2):
            raise ValueError(f"y速度超出范围: {y}")
        if not (-0.4 <= z <= 0.4):
            raise ValueError(f"z速度超出范围: {z}")
```

## 8. 性能优化建议

### 8.1 连接稳定性
- 保持设备距离在10米以内
- 避免2.4GHz WiFi干扰
- 实现断线自动重连
- 定期发送心跳包

### 8.2 指令发送频率
- 控制指令: 最高20Hz（推荐10Hz）
- 心跳指令: 2Hz
- 状态查询: 按需或通知模式

### 8.3 电源管理
- 长时间不使用时发送停止指令
- 实现低功耗模式
- 监控机器人电池状态

## 9. 开发工具推荐

### 9.1 BLE调试工具
- **nRF Connect** (Android/iOS): Nordic官方BLE调试工具
- **BlueZ工具** (Linux): `bluetoothctl`, `hcitool`, `gatttool`
- **BLE Scanner** (Android): 第三方BLE扫描工具

### 9.2 开发环境
- **Python**: 推荐使用`bleak`库，跨平台支持好
- **Android**: Android Studio + BluetoothLE API
- **iOS**: Xcode + Core Bluetooth框架
- **Web**: Web Bluetooth API（需要HTTPS）

### 9.3 测试工具
```bash
# Linux下测试BLE连接
bluetoothctl scan on
bluetoothctl connect [MAC地址]

# 写入测试指令
echo '{"cmd":"ping"}' | xxd -r -p > /tmp/test_cmd
gatttool -b [MAC地址] --char-write-req -a 0x0012 -n $(xxd -p /tmp/test_cmd)
```

## 10. 示例项目

### 10.1 基础遥控器
完整的Python GUI遥控器示例，包含：
- 设备扫描和连接
- 实时状态显示
- 方向键控制
- 速度调节
- 自动心跳

### 10.2 游戏手柄控制
支持Xbox/PS4手柄的实时控制：
- 摇杆模拟运动
- 按键映射
- 振动反馈
- 多手柄支持

### 10.3 Web控制台
基于Web Bluetooth的浏览器控制：
- 无需安装应用
- 支持PWA
- 触屏友好
- 实时视频（如果有摄像头）

## 11. API参考速查

### 11.1 指令速查表
```json
// 基础运动
{"cmd":"move","x":0.2,"y":0,"z":0}        // 前进
{"cmd":"move","x":-0.2,"y":0,"z":0}       // 后退
{"cmd":"move","x":0,"y":0.2,"z":0}        // 左移
{"cmd":"move","x":0,"y":-0.2,"z":0}       // 右移
{"cmd":"move","x":0,"y":0,"z":-0.4}       // 左转
{"cmd":"move","x":0,"y":0,"z":0.4}        // 右转
{"cmd":"stop"}                            // 停止

// 按键模拟
{"cmd":"button","button":1}               // 前进键
{"cmd":"button","button":2}               // 后退键
{"cmd":"button","button":4}               // 启动/右移键

// 系统指令
{"cmd":"ping"}                            // 心跳
{"cmd":"center_adjust","adjust":1}        // 重心调节
```

### 11.2 UUID速查表
```
服务UUID:    12345678-1234-1234-1234-123456789abc
指令特征值:   87654321-4321-4321-4321-cba987654321  (WRITE)
状态特征值:   11111111-2222-3333-4444-555555555555  (READ | NOTIFY)
```

### 11.3 参数范围
```
x轴速度: -0.2 ~ 0.2 m/s
y轴速度: -0.2 ~ 0.2 m/s  
z轴速度: -0.4 ~ 0.4 rad/s
心跳间隔: < 2秒
指令频率: < 20Hz
```

---

## 技术支持

如有开发问题，请参考：
1. 检查机器人启动脚本是否包含BLE初始化
2. 确认蓝牙适配器状态正常（UP RUNNING）
3. 验证JSON指令格式和参数范围
4. 使用BLE调试工具验证连接

**注意**: 本指南基于当前版本的BLE GATT实现，如有协议更新请参考最新的`ble_gatt_server.py`文件。